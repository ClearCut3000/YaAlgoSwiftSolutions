//
//  SameAmounts.swift
//
/*
 -- ПРИНЦИП РАБОТЫ --
 Алгоритм проверки возможности разделения массива чисел на два подмножества с одинаковой суммой использует метод динамического программирования. Сначала вычисляется общая сумма всех элементов массива. Если эта сумма нечетная, то разделение на два равных подмножества невозможно, и алгоритм сразу возвращает `false`. Если сумма четная, алгоритм проверяет, можно ли сформировать подмножество с суммой, равной половине от общей суммы (это и есть целевая сумма).
 Для этого используется массив `dp`, в котором `dp[i]` указывает, можно ли составить сумму `i` с помощью подмножества элементов исходного массива. Изначально `dp[0]` установлено в `true`, так как сумма 0 всегда достижима (с использованием пустого подмножества). Алгоритм затем проходит по каждому числу в массиве и обновляет возможные суммы в массиве `dp`, проверяя, можно ли достичь суммы `i`, добавив текущее число.
 Если по окончании процесса `dp[target]` равно `true`, значит, возможно найти подмножество с суммой, равной половине от общей суммы, и алгоритм возвращает `true`. В противном случае, возвращается `false`.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Алгоритм корректен, так как он основан на методе динамического программирования, который гарантирует нахождение всех возможных сумм, которые можно составить с использованием элементов массива. Массив `dp` представляет собой булевый массив, где каждая ячейка `dp[i]` указывает, можно ли сформировать сумму `i` с помощью подмножества элементов. Поскольку алгоритм последовательно рассматривает все элементы массива и обновляет возможные суммы, он гарантированно найдет решение (если оно существует). Корректность также обеспечивается тем, что начальная проверка на четность суммы устраняет заведомо неразделимые случаи.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Временная сложность алгоритма составляет O(n * target), где n — количество элементов в массиве, а target — половина от общей суммы элементов массива. Это связано с тем, что для каждого элемента массива производится обновление состояния всех возможных сумм от 0 до target. Таким образом, временная сложность линейно зависит как от числа элементов, так и от значения целевой суммы.

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Пространственная сложность алгоритма составляет O(target), где target — половина от общей суммы элементов массива. Это связано с тем, что используется одномерный массив `dp` длиной target + 1 для хранения информации о достижимости каждой суммы. Память используется эффективно, так как массив обновляется на месте, что минимизирует дополнительные затраты на хранение данных.
 */

import Foundation

func canPartition(_ nums: [Int], _ n: Int) -> Bool {
    let totalSum = nums.reduce(0, +)

    // Если общая сумма нечетная, разделение невозможно
    if totalSum % 2 != 0 || n < 2 {
        return false
    }

    let target = totalSum / 2
    var dp = Array(repeating: false, count: target + 1)
    dp[0] = true

    // Основная логика
    for num in nums {
        for i in stride(from: target, through: num, by: -1) {
            dp[i] = dp[i - num] || dp[i]
        }
    }
    return dp[target]
}

let n = Int(readLine()!)!
let numbers = readLine()!.split(separator: " ").map { Int($0)! }

print(String(canPartition(numbers, n)).capitalized)
