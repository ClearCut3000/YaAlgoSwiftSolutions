//
//  LowensteinDistance.swift
//
/*
 -- ПРИНЦИП РАБОТЫ --
 Оптимизированный алгоритм вычисления расстояния Левенштейна между двумя строками `s` и `t` использует динамическое программирование для нахождения минимального числа операций (вставка, удаление, замена символа), необходимых для преобразования одной строки в другую. Основная идея заключается в том, чтобы сократить использование памяти за счет хранения только двух строк динамической таблицы `dp` вместо всей матрицы `m x n`. Алгоритм последовательно заполняет эти строки, вычисляя минимальное количество операций для преобразования текущих префиксов строк `s` и `t`.
 Для реализации используются два одномерных массива: `previous` и `current`, которые представляют строки таблицы `dp`. `previous` хранит значения из предыдущей итерации, а `current` — значения текущей строки. После завершения обработки строки `s`, массивы меняются местами для следующей итерации. Это позволяет вычислять расстояние Левенштейна последовательно, минимизируя использование памяти.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Корректность алгоритма гарантируется тем, что он сохраняет основную структуру динамического программирования, применяя её к оптимизированной версии. Каждый элемент массива `current[j]` рассчитывается на основе минимального количества операций для преобразования префикса строки `s` длиной `i` в префикс строки `t` длиной `j`. Выбор между вставкой, удалением и заменой символа обеспечивает оптимальный подсчет операций для каждой пары префиксов.
 Инициализация первой строки (когда `i=0`) устанавливает базовый случай, где необходимо `j` операций для преобразования пустой строки в префикс строки `t` длиной `j`. Таким образом, вся структура алгоритма сохраняет свою корректность, и итоговое значение в `previous[n]` после завершения всех итераций будет содержать правильное расстояние Левенштейна.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Временная сложность алгоритма `O(m * n)`, где `m` — длина строки `s`, а `n` — длина строки `t`. Алгоритм проходит по всем символам обеих строк, выполняя константное количество операций для каждого элемента.

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Пространственная сложность оптимизирована до `O(n)`, где `n` — длина строки `t`. Вместо хранения полной матрицы размером `m x n`, требуется хранить только два одномерных массива длиной `n`, которые используются для хранения текущих и предыдущих строк таблицы `dp`.
 */

import Foundation

func levenshteinDistance(s: String, t: String) -> Int {
  let sChars = Array(s)
  let tChars = Array(t)
  let m = sChars.count
  let n = tChars.count

  // Используем две строки для хранения текущей и предыдущей строки dp
  var previous = Array(repeating: 0, count: n + 1)
  var current = Array(repeating: 0, count: n + 1)

  // Инициализация первой строки
  for j in 0...n {
    previous[j] = j
  }

  // Заполнение таблицы dp только двумя строками
  for i in 1...m {
    current[0] = i
    for j in 1...n {
      if sChars[i - 1] == tChars[j - 1] {
        current[j] = previous[j - 1]
      } else {
        current[j] = min(previous[j] + 1,        // Удаление
                         current[j - 1] + 1,     // Вставка
                         previous[j - 1] + 1)    // Замена
      }
    }
    // Обновляем previous для следующей итерации
    swap(&previous, &current)
  }

  // Результат в последнем элементе предыдущей строки
  return previous[n]
}

if let s = readLine(), let t = readLine() {
  let distance = levenshteinDistance(s: s, t: t)
  print(distance)
}
