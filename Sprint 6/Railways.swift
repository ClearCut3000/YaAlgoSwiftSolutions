//
//  Railways.swift
//
/*
 -- ПРИНЦИП РАБОТЫ --
 Алгоритм проверяет, является ли карта железных дорог в стране оптимальной, что означает отсутствие циклов с дорогами разного типа. Оптимальность карты подразумевает, что для любой пары городов A и B существует либо единственный тип дорог, соединяющий их, либо маршрут между этими городами отсутствует.
 В данной реализации используется **ориентированный граф**, где города представлены вершинами, а дороги между ними — рёбрами графа. Дороги типа 'R' (Red) и 'B' (Blue) интерпретируются
 как ориентированные рёбра. Если дорога типа 'R', то добавляется ребро от города с большим номером к городу с меньшим номером, таким образом происходит перенаправление ребра. Если дорога типа 'B', то добавляется ребро в обычном направлении — от города с меньшим номером к большему.
 Для проверки наличия циклов в графе применяется обход в глубину (DFS). Во время обхода каждая вершина может находиться в одном из трёх состояний (цветов):
 - Белый (white): вершина ещё не была посещена.
 - Серый (gray): вершина обрабатывается (то есть находится в стеке рекурсии).
 - Чёрный (black): все смежные с вершиной вершины были полностью обработаны.
 Если в процессе обхода обнаруживается, что смежная вершина уже имеет серый цвет, это свидетельствует о наличии цикла в графе, что означает, что существует возможность добраться из одного города в другой по разным типам дорог. В этом случае алгоритм сразу возвращает "NO", указывая, что карта не является оптимальной. Если обход завершён и циклы не обнаружены, граф ацикличен, и программа возвращает "YES", подтверждая оптимальность карты.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

 Для доказательства корректности алгоритма будем использовать **инвариант**, который сохраняется на протяжении всего выполнения алгоритма:
 Инвариант: на каждом шаге обхода в глубину (DFS) для любой текущей вершины, которая помечена серым цветом, не существует обратного пути (по другим типам дорог), ведущего к одной из ранее посещённых вершин, также помеченных серым цветом.
 Теперь рассмотрим, как изменение направления рёбер типа "R" влияет на этот инвариант и доказательство корректности:
 1. Перенаправление рёбер типа "R": В ходе построения графа, если дорога типа "R" ведёт из города с меньшим номером в город с большим номером (например, из города A в город B), направление ребра в графе меняется на обратное (из B в A). Это необходимо для того, чтобы построенный граф мог корректно отражать ограничения задачи. В этом случае, все дороги типа "B" сохраняют своё направление (из A в B).
 2. Цель перенаправления рёбер: Перенаправление рёбер типа "R" позволяет гарантировать, что если в графе существует цикл, то этот цикл будет указывать на наличие маршрутов обоих типов между городами, что противоречит условиям задачи. Перенаправленные рёбра типа "R" создают ситуации, в которых граф может потенциально стать циклическим, что и проверяется алгоритмом.
 3. Проверка инварианта: Инвариант сохраняется, так как на каждом шаге обхода, если текущая вершина (город) помечена серым цветом, это означает, что она ещё не завершила свою обработку. Если в процессе обхода найдена смежная вершина, которая также помечена серым цветом, это свидетельствует о наличии цикла, так как существует путь через рёбра разных типов, который возвращает нас к ранее посещённой вершине. Этот цикл нарушает условия оптимальности карты, так как позволяет строить маршруты обоих типов между городами.
 4. Завершение обхода: Если обход графа завершён, и инвариант не был нарушен (т.е. не обнаружен цикл), это означает, что все рёбра, включая перенаправленные рёбра типа "R", не образуют циклов. Следовательно, между любой парой городов невозможно построить маршруты разного типа, что подтверждает оптимальность карты. Алгоритм возвращает "YES".
 Логический вывод: Перенаправление рёбер типа "R" является ключевым шагом в построении графа, который позволяет выявить наличие циклов, указывающих на неоптимальность карты. Если бы рёбра типа "R" не перенаправлялись, то возможные циклы могли бы не быть обнаружены, и инвариант был бы нарушен. Поэтому корректность алгоритма обеспечивается тем, что направление рёбер типа "R" изменяется так, чтобы потенциальные циклы стали видимыми для алгоритма DFS.
 Таким образом, корректность алгоритма вытекает из правильного построения графа и сохранения инварианта, который гарантирует отсутствие циклов. Если алгоритм завершает работу без обнаружения цикла, то карта железных дорог является оптимальной.

 -- ДОКАЗАТЕЛЬСТВО ТОГО ЧТО ПОИСК ЦИКЛА В ГРАФЕ РЕШАЕТ ЗАДАЧУ  --
 Условие задачи: Карта железных дорог называется оптимальной, если не существует пары городов A и B такой, что можно добраться от A до B как по дорогам типа R (Reverse), так и по дорогам типа B.
 В графе, где можно двигаться только от меньшего номера к большему, невозможно существование циклов. Однако, нам нужно убедиться, что даже при инвертировании рёбер типа R, поиск циклов в модифицированном графе корректно решает задачу.
 Доказательство:
 Исходный граф: В исходном графе, где движение разрешено только от меньшего номера к большему, нет циклов по определению. Это связано с тем, что циклы требуют возможности вернуться к исходной вершине, что невозможно при одностороннем направлении рёбер.
 Модификация графа: Чтобы проверить, является ли карта железных дорог оптимальной, мы инвертируем направления рёбер типа R (из большого номера в меньший). В результате мы получаем граф, где некоторые рёбра теперь направлены обратно.
 Проверка наличия циклов: После инвертирования рёбер типа R:
 Если в модифицированном графе существует цикл, это указывает на то, что между некоторыми вершинами можно достигать их как через прямые, так и через инвертированные рёбра. Это нарушает условие оптимальности карты, так как мы можем двигаться между городами по дорогам разных типов, образуя цикл.
 Интерпретация циклов:
 Если в модифицированном графе обнаружен цикл, это означает, что в исходном графе между некоторыми парами городов существует возможность достичь одного города разными путями (сначала прямым, затем обратным, или наоборот), что нарушает условие задачи.
 Рассмотрим три города 1, 2 и 3:
 1 --B--> 2 --B--> 3
  \               /
   \------R------/
 В оригинальной конфигурации:
 - От города 1 до города 2 можно добраться по дороге типа B.
 - От города 1 до города 3 можно добраться по дороге типа R.
 - От города 2 до города 3 можно добраться по дороге типа B.
 При инверсии рёбер типа R (дорога между городами 1 и 3 теперь идет в обратном направлении), появляется цикл:
 - 1 -> 2 -> 3 -> 1
 Этот цикл указывает на то, что можно пройти из города 1 в город 3 двумя способами — через дорогу типа B и через дорогу типа R. Следовательно, карта железных дорог не является оптимальной.
 Обнаружение цикла в модифицированном графе с инвертированными рёбрами типа R подтверждает, что карта железных дорог не является оптимальной. Цикл в этом контексте указывает на наличие маршрутов между городами, которые могут быть достигнуты как прямыми, так и обратными путями.
 Итог: Поиск любого цикла в модифицированном графе (с инвертированными рёбрами типа R) позволяет проверить оптимальность карты железных дорог. Если цикл обнаружен, это указывает на наличие маршрутов разного типа между некоторыми парами городов, что нарушает условия оптимальности. Поэтому обнаружение цикла в модифицированном графе корректно решает задачу.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Временная сложность алгоритма составляет O(V + E), где V — количество вершин (городов), а E — количество рёбер (дорог). Эта сложность достигается за счёт того, что каждая вершина и каждое ребро обрабатываются только один раз в процессе обхода.

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Пространственная сложность также составляет O(V + E). Она обусловлена необходимостью хранения списка смежности для рёбер графа и массива для отслеживания состояния каждой вершины.
 */

import Foundation

// Протокол для работы с графом
protocol GraphProtocol {
  func addEdge(from: Int, to: Int)
  func hasEdge(from: Int, to: Int) -> Bool
}

// Определение цветов для вершин графа
enum Color {
  case white, gray, black
}

// Класс для представления графа с использованием матрицы смежности
class Graph: GraphProtocol {
  private var adjacencyMatrix: [[Bool]]

  init(verticesCount: Int) {
    adjacencyMatrix = Array(repeating: Array(repeating: false, count: verticesCount + 1), count: verticesCount + 1)
  }

  func addEdge(from: Int, to: Int) {
    adjacencyMatrix[from][to] = true
  }

  func hasEdge(from: Int, to: Int) -> Bool {
    return adjacencyMatrix[from][to]
  }
}

// Класс для выполнения обхода в глубину (DFS) и поиска циклов
class DFS {
  private var colors: [Color]

  init(verticesCount: Int) {
    colors = Array(repeating: .white, count: verticesCount + 1)
  }

  func findCycle(in graph: GraphProtocol, startVertex: Int) -> Bool {
    var stack: [Int] = []
    stack.append(startVertex)

    while !stack.isEmpty {
      let vertex = stack.removeLast()

      if colors[vertex] == .white {
        colors[vertex] = .gray
        stack.append(vertex)

        for neighbor in 1..<colors.count {
          if graph.hasEdge(from: vertex, to: neighbor) {
            if colors[neighbor] == .gray {
              // Найден цикл
              return true
            } else if colors[neighbor] == .white {
              stack.append(neighbor)
            }
          }
        }
      } else if colors[vertex] == .gray {
        colors[vertex] = .black
      }
    }

    return false
  }

  func getColor(for vertex: Int) -> Color {
    return colors[vertex]
  }
}

// Основная функция
func main() {
  let verticesCount = Int(readLine()!)!
  if verticesCount == 1 {
    print("YES")
    return
  }

  let graph = Graph(verticesCount: verticesCount)

  // Заполнение графа
  for i in 1..<verticesCount {
    let roadTypes = Array(readLine()!)
    for j in 0..<roadTypes.count {
      let isDirect = roadTypes[j] == "B"
      if isDirect {
        graph.addEdge(from: i, to: i + j + 1)
      } else {
        graph.addEdge(from: i + j + 1, to: i)
      }
    }
  }

  let dfs = DFS(verticesCount: verticesCount)
  var startVertex = 1

  var existCycle = dfs.findCycle(in: graph, startVertex: startVertex)

  if existCycle {
    print("NO")
    return
  }

  for j in 2...verticesCount {
    if dfs.getColor(for: j) == .white {
      existCycle = dfs.findCycle(in: graph, startVertex: j)
      if existCycle {
        print("NO")
        return
      }
    }
  }

  print("YES")
}

main()
