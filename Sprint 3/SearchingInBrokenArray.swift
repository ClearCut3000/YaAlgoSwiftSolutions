//
//  SearchingInBrokenArray.swift
//

/*
 -- ПРИНЦИП РАБОТЫ --
 Функция brokenSearch использует бинарный поиск с модификацией для работы с "сломанным" (сдвинутым) массивом.
 Два указателя (left и right) устанавливаются за пределами начала и конца массива соответственно.
 Цикл выполняется до тех пор, пока right больше left + 1. Это условие гарантирует, что диапазон поиска содержит более одного элемента.
 Вычисление середины массива обеспечивает равномерное деление диапазона между указателями left и right.
 Проверка центрального элемента:
 Если arr[mid] == elem, то элемент elem найден в массиве, и возвращается индекс mid.
 Если arr[mid] < elem, то искомый элемент elem находится в правой половине массива. Устанавливается новое значение left = mid, чтобы сузить диапазон поиска.
 Если arr[mid] >= elem, то искомый элемент elem находится в левой половине массива. Устанавливается новое значение right = mid, чтобы сузить диапазон поиска.
 Определяем, какая половина массива отсортирована, и соответственно сдвигаем указатели для продолжения поиска в отсортированной половине.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Алгоритм работает как стандартный бинарный поиск, но с дополнительными проверками для определения отсортированной половины массива.
 Это позволяет корректно обрабатывать случаи, когда массив сдвинут.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 В каждой итерации цикла отбрасывается половина массива, что дает логарифмическую сложность O(logn).

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Алгоритм использует только несколько дополнительных переменных, поэтому пространственная сложность составляет O(1).
 */

import Foundation

func brokenSearch(arr: [Int], elem: Int) -> Int {
  var left = -1
  var right = arr.count

  while right > left + 1 {
    let mid = left + (right - left) / 2

    if arr[mid] == elem { return mid }

    // Check which part is sorted
    if arr[left + 1] <= arr[mid] {
      // Left part is sorted
      if arr[left + 1] <= elem && elem < arr[mid] {
        right = mid
      } else {
        left = mid
      }
    } else {
      // Right part is sorted
      if arr[mid] < elem && elem <= arr[right - 1] {
        left = mid
      } else {
        right = mid
      }
    }
  }
  return -1
}
