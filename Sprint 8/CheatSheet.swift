//
//  CheatSheet.swift
//
/*
 -- ПРИНЦИП РАБОТЫ --
 Алгоритм решает задачу разбиения строки на слова из заданного словаря с использованием префиксного дерева (Trie) и метода динамического программирования (DP). Основная идея заключается в том, чтобы проверить, можно ли последовательно разобрать текст на подстроки, каждая из которых присутствует в словаре.
 1. Сначала строится префиксное дерево (Trie) из допустимых слов. Каждый узел дерева содержит ссылки на дочерние узлы и флаг, который указывает, является ли текущий узел концом слова.
 2. Затем строка проходит проверку с использованием динамического программирования. Для этого создается массив `dp`, где `dp[i]` указывает, можно ли разбить подстроку от начала строки до позиции `i` на слова из словаря.
 Что будет храниться в `dp`?
 В массиве `dp` хранится информация о том, можно ли разбить подстроку от начала строки до индекса `i` на слова из словаря. `dp[i] == true` означает, что подстрока от начала строки до позиции `i` может быть составлена из допустимых слов.
 - Каким будет базовый случай для задачи?
 Базовым случаем будет `dp[0] = true`, так как пустая строка всегда может быть разбита (например, без использования слов).
 - Каким будет переход динамики?
 Переход динамики происходит следующим образом: если `dp[start]` истинно, это значит, что подстрока от начала до `start` может быть разобрана, и мы проверяем возможные окончания слов в Trie, начиная с этой позиции. Если находим подходящее слово, то обновляем `dp[end] = true`, где `end` — индекс конца найденного слова.
 - Каким будет порядок вычисления данных в массиве `dp`?
 Данные в массиве `dp` вычисляются слева направо, начиная с базового случая. Для каждой позиции `start`, если `dp[start] == true`, мы пытаемся найти все возможные слова, начиная с этой позиции, обновляя соответствующие позиции в массиве `dp`.
 - Где будет располагаться ответ на исходный вопрос?
 Ответ будет находиться в последней ячейке массива `dp`, то есть `dp[n]`, где `n` — длина строки `text`. Если `dp[n] == true`, значит, строку можно разбить на слова из словаря, и программа выводит "YES", иначе "NO".

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Алгоритм корректен, так как использует префиксное дерево для эффективного поиска слов в строке и динамическое программирование для отслеживания возможных разбиений строки. Переход динамики основан на том, что, если на некотором индексе строку можно разбить на слова из словаря, то мы можем продолжать проверять подстроки, начиная с этого индекса. Использование Trie позволяет эффективно искать подстроки, минимизируя количество ненужных проверок.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Временная сложность алгоритма составляет O(n * m), где n — длина строки `text`, а m — средняя длина слов в словаре. Это связано с тем, что для каждого индекса строки мы можем выполнить проверку по префиксному дереву до тех пор, пока не найдем соответствующее слово.

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Пространственная сложность составляет O(n + L), где n — длина строки, а L — суммарная длина всех слов в словаре. Это связано с тем, что используется массив `dp` длиной n для хранения информации о достижимости индексов и префиксное дерево для хранения всех возможных слов.
 */

import Foundation

// Узел Trie (префиксного дерева)
class TrieNode {
  var children: [Character: TrieNode] = [:]
  var isWordEnd: Bool = false
}

// Класс для решения задачи с использованием Trie и динамического программирования
class WordBreaker {
  private let root = TrieNode()

  // Инициализация словаря (Trie) с набором слов
  init(words: [String]) {
    for word in words {
      insert(word: word)
    }
  }

  // Вставка слова в Trie
  private func insert(word: String) {
    var currentNode = root
    for char in word {
      if currentNode.children[char] == nil {
        currentNode.children[char] = TrieNode()
      }
      currentNode = currentNode.children[char]!
    }
    currentNode.isWordEnd = true
  }

  // Метод для проверки возможности разбиения строки на слова из словаря
  func canBreak(_ text: String) -> Bool {
    let characters = Array(text)
    let length = characters.count
    var dp = Array(repeating: false, count: length + 1)
    dp[0] = true // Пустая строка всегда может быть разбита

    for start in 0..<length {
      if dp[start] {
        var currentNode = root
        var end = start
        while end < length, let nextNode = currentNode.children[characters[end]] {
          currentNode = nextNode
          if currentNode.isWordEnd {
            dp[end + 1] = true
          }
          end += 1
        }
      }
    }
    return dp[length]
  }
}

// Главный класс для чтения входных данных и выполнения задачи
class Main {
  func run() {
    let text = readLine()!
    let numberOfWords = Int(readLine()!)!
    var wordList: [String] = []

    for _ in 0..<numberOfWords {
      wordList.append(readLine()!)
    }

    let wordBreaker = WordBreaker(words: wordList)
    let result = wordBreaker.canBreak(text)
    print(result ? "YES" : "NO")
  }
}

let program = Main()
program.run()
